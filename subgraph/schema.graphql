enum Role {
  Public # Regular user (can buy credits, browse marketplace, etc.)
  Developer # Project developer who submits proposals and proofs
  Auditor # Independent verifier who reviews proposals and proofs
}

enum Standard {
  GoldStandard # Gold Standard certification
  VCS # Verified Carbon Standard (VCS)
  Shariah # Shariah-compliant standard
}

enum ProposalStatus {
  PendingReview # Submitted and awaiting auditor review
  ChangesRequested # Auditor requested modifications
  Rejected # Proposal rejected by auditor
  Approved # Proposal approved, can progress to project creation
}

enum ProjectStatus {
  None # No project created yet
  InProgress # Active project under execution
  ProofSubmitted # Proof of impact submitted by developer
  AuditRejected # Auditor rejected the submitted proof
  Finalized # Project finalized, credits can be issued
}

enum ReviewAction {
  Approve # Auditor approves the submission
  RequestChanges # Auditor requests revisions
  Reject # Auditor rejects the submission
}

enum ListingStatus {
  Active # Listing is active and available for purchase
  Cancelled # Seller cancelled the listing
  Filled # Listing is fully purchased / sold out
}

type User @entity {
  id: ID!
  role: Role! # Role (Public, Developer, Auditor)
  documentCid: String # KYC document IPFS CID
  proofOfAddressCid: String # Proof of address IPFS CID
  certificationCid: String # Certification (e.g. auditor credentials) IPFS CID
  proposals: [Proposal!]! @derivedFrom(field: "developer") # Proposals submitted by developer
  reviews: [ProposalReview!]! @derivedFrom(field: "auditor") # Reviews submitted by auditor
  proofs: [Proof!]! @derivedFrom(field: "developer") # Proofs submitted by developer
  creditBalances: [CreditBalance!]! @derivedFrom(field: "user") # User’s credit balances
}

type Proposal @entity {
  id: ID!
  developer: User! # Developer who submitted the proposal
  name: String! # Name of the project
  description: String! # Description of the project
  location: String! # Geographical location
  estimatedCredits: BigInt! # Estimated credits from project
  vintage: Int! # Vintage year of the credits
  methodology: String! # Methodology applied (e.g. CDM, VCS methodology)
  projectPlanCID: String! # Project plan stored on IPFS
  eiaCID: String! # Environmental Impact Assessment (EIA) on IPFS
  otherDocsCID: String! # Other supporting documents
  metadataCID: String! # Metadata (e.g. maps, satellite images)
  submittedAt: Timestamp! # Submission timestamp
  standard: Standard! # Standard applied (Gold Standard, VCS, etc.)
  status: ProposalStatus! # Current status of the proposal
  reviews: [ProposalReview!]! @derivedFrom(field: "proposal") # Auditor reviews
  project: Project @derivedFrom(field: "proposal") # Linked project (if approved)
}

type ProposalReview @entity {
  id: ID!
  proposal: Proposal! # Proposal being reviewed
  auditor: User! # Auditor performing the review
  action: ReviewAction! # Auditor’s decision
  commentCID: String # Comments stored on IPFS
  timestamp: Timestamp! # Review timestamp
}

type Project @entity {
  id: ID! # Project ID
  proposal: Proposal! # Linked proposal
  developer: User! # Developer of the project
  status: ProjectStatus! # Current project status
  proofs: [Proof!]! @derivedFrom(field: "project") # Proof submissions
  credit: CreditBatch @derivedFrom(field: "project") # Credits issued from the project
  createdAt: Timestamp! # Creation timestamp
}

type Proof @entity {
  id: ID!
  project: Project! # Linked project
  developer: User! # Developer who submitted
  proofCID: String! # Proof (data, report, evidence) stored on IPFS
  audits: [ProofAudit!]! @derivedFrom(field: "proof") # Auditor reviews of the proof
  submittedAt: Timestamp! # Submission timestamp
}

type ProofAudit @entity {
  id: ID!
  proof: Proof! # Proof being audited
  auditor: User! # Auditor performing the review
  action: ReviewAction! # Auditor’s decision
  commentCID: String # Comments stored on IPFS
  timestamp: Timestamp! # Audit timestamp
}

type CreditBatch @entity {
  id: ID! # ERC1155 token ID
  project: Project # Project that generated the credits
  developer: User # Developer who owns the credits
  amount: BigInt! # Total amount of credits issued
  issuedAt: Timestamp! # Issuance timestamp
  tokenURI: String! # Metadata URI for the token
  retiredAmount: BigInt! # Total credits retired from this batch
  creditBalances: [CreditBalance!]! @derivedFrom(field: "batch") # Holders of this batch
}

type CreditBalance @entity {
  id: ID!
  user: User! # User holding the credits
  batch: CreditBatch! # Credit batch
  balance: BigInt! # Balance of credits owned
}

type MarketplaceListing @entity {
  id: ID! # Listing ID
  seller: User! # User selling the credits
  token: CreditBatch! # Credit batch being sold
  amount: BigInt! # Total amount listed for sale
  remaining: BigInt! # Remaining unsold amount
  pricePerUnit: BigInt! # Price per unit credit
  startTime: Timestamp # Start time of the listing
  endTime: Timestamp # End time of the listing
  status: ListingStatus! # Current status of the listing
  createdAt: Timestamp! # Listing creation time
  updatedAt: Timestamp! # Last update time
  purchases: [MarketplacePurchase!]! @derivedFrom(field: "listing") # Purchases made
}

# Transactions / Events for Statistics

type CreditsIssued @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  developer: User! # address
  amount: BigInt! # uint256
  tokenId: BigInt! # uint256
  tokenURI: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type ProjectProposed @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  developer: User! # address
  meta_name: String! # string
  meta_description: String! # string
  meta_location: String! # string
  meta_estimatedCredits: BigInt! # uint256
  meta_standard: Standard! # uint8
  meta_vintage: Int! # uint16
  meta_methodology: String! # string
  meta_projectPlanCID: String! # string
  meta_eiaCID: String! # string
  meta_otherDocsCID: String! # string
  meta_metadataCID: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type ProposalReviewed @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  auditor: User! # address
  action: Int! # uint8
  commentCID: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type ProofAudited @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  auditor: User! # address
  action: BigInt! # uint8
  commentCID: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type CreditsRetired @entity(timeseries: true) {
  id: Int8!
  holder: User! # who retired
  tokenId: BigInt! # which batch
  amount: BigInt! # retired amount
  retirementCID: String
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type Transaction @entity(timeseries: true) {
  id: Int8!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  value: BigInt! # uint256
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type MarketplacePurchase @entity(timeseries: true) {
  id: Int8!
  listing: MarketplaceListing!
  buyer: User!
  quantity: BigInt!
  totalPaid: BigInt!
  feePaid: BigInt!
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type Listed @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  seller: Bytes! # address
  tokenId: BigInt! # uint256
  amount: BigInt! # uint256
  pricePerUnit: BigInt! # uint256
  startTime: BigInt! # uint64
  endTime: BigInt! # uint64
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type DailyProjectStats
  @aggregation(intervals: ["day"], source: "ProjectProposed") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "count")
}

type DailyProofStats @aggregation(intervals: ["day"], source: "ProofAudited") {
  id: Int8!
  timestamp: Timestamp!

  approvals: BigInt!
    @aggregate(fn: "count", arg: "case when action = 0 then 1 else null end")

  rejections: BigInt!
    @aggregate(fn: "count", arg: "case when action = 2 then 1 else null end")
}

type DailyReviewStats
  @aggregation(intervals: ["day"], source: "ProposalReviewed") {
  id: Int8!
  timestamp: Timestamp!
  count: BigInt! @aggregate(fn: "count")
  approvals: BigInt!
    @aggregate(fn: "count", arg: "case when action = 0 then 1 else null end")

  rejections: BigInt!
    @aggregate(fn: "count", arg: "case when action = 2 then 1 else null end")
}

type DailyCreditStats
  @aggregation(intervals: ["day"], source: "CreditsIssued") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "sum", arg: "amount")
}

type DailyRetirementStats
  @aggregation(intervals: ["day"], source: "CreditsRetired") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "sum", arg: "amount")
  count: BigInt! @aggregate(fn: "count")
}

type DailyTransactionStats
  @aggregation(intervals: ["day"], source: "Transaction") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "sum", arg: "value")
  count: BigInt! @aggregate(fn: "count")
}

type DailyMarketplaceStats
  @aggregation(intervals: ["day"], source: "MarketplacePurchase") {
  id: Int8!
  timestamp: Timestamp!

  dailyVolume: BigInt! @aggregate(fn: "sum", arg: "totalPaid")
  dailyFees: BigInt! @aggregate(fn: "sum", arg: "feePaid")
  dailyPurchases: BigInt! @aggregate(fn: "count")
}

type DailyMarketplaceListingStats
  @aggregation(intervals: ["day"], source: "Listed") {
  id: Int8!
  timestamp: Timestamp!
  dailyListings: BigInt! @aggregate(fn: "count")
}
