enum Role {
  Public
  Developer
  Auditor
}

enum Standard {
  GoldStandard
  VCS
  Shariah
}

enum ProposalStatus {
  PendingReview
  ChangesRequested
  Rejected
  Approved
}

enum ProjectStatus {
  None
  InProgress
  ProofSubmitted
  AuditRejected
  Finalized
}

enum ReviewAction {
  Approve
  RequestChanges
  Reject
}

type User @entity {
  id: ID!
  role: Role!
  documentCid: String
  proofOfAddressCid: String
  certificationCid: String
  proposals: [Proposal!]! @derivedFrom(field: "developer")
  reviews: [ProposalReview!]! @derivedFrom(field: "auditor")
  proofs: [Proof!]! @derivedFrom(field: "developer")
}

type Proposal @entity {
  id: ID!
  developer: User!
  name: String!
  description: String!
  location: String!
  estimatedCredits: BigInt!
  vintage: Int!
  methodology: String!
  projectPlanCID: String!
  eiaCID: String!
  otherDocsCID: String!
  metadataCID: String!
  submittedAt: Timestamp!
  standard: Standard!
  status: ProposalStatus!
  reviews: [ProposalReview!]! @derivedFrom(field: "proposal")
  project: Project @derivedFrom(field: "proposal")
}

type ProposalReview @entity {
  id: ID!
  proposal: Proposal!
  auditor: User!
  action: ReviewAction!
  commentCID: String
  timestamp: Timestamp!
}

type Project @entity {
  id: ID! # projectId
  proposal: Proposal!
  developer: User!
  status: ProjectStatus!
  proofs: [Proof!]! @derivedFrom(field: "project")
  credits: [CreditBatch!]! @derivedFrom(field: "project")
  createdAt: Timestamp!
}

type Proof @entity {
  id: ID!
  project: Project!
  developer: User!
  proofCID: String!
  audits: [ProofAudit!]! @derivedFrom(field: "proof")
  submittedAt: Timestamp!
}

type ProofAudit @entity {
  id: ID!
  proof: Proof!
  auditor: User!
  action: ReviewAction!
  commentCID: String
  timestamp: Timestamp!
}

# CreditBatch (ERC1155 issuances)
type CreditBatch @entity {
  id: ID! # tokenId
  project: Project!
  developer: User!
  amount: BigInt!
  issuedAt: Timestamp!
  tokenURI: String!
}

type CreditBalance @entity {
  id: ID!
  user: User!
  batch: CreditBatch!
  balance: BigInt!
}

# Transactions / Events for Statistics

type CreditsIssued @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  developer: User! # address
  amount: BigInt! # uint256
  tokenId: BigInt! # uint256
  tokenURI: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type ProjectProposed @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  developer: User! # address
  meta_name: String! # string
  meta_description: String! # string
  meta_location: String! # string
  meta_estimatedCredits: BigInt! # uint256
  meta_standard: Standard! # uint8
  meta_vintage: Int! # uint16
  meta_methodology: String! # string
  meta_projectPlanCID: String! # string
  meta_eiaCID: String! # string
  meta_otherDocsCID: String! # string
  meta_metadataCID: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type ProposalReviewed @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  auditor: User! # address
  action: Int! # uint8
  commentCID: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type ProofAudited @entity(timeseries: true) {
  id: Int8!
  internal_id: BigInt! # uint256
  auditor: User! # address
  action: BigInt! # uint8
  commentCID: String! # string
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type Transaction @entity(timeseries: true) {
  id: Int8!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  value: BigInt! # uint256
  blockNumber: BigInt!
  timestamp: Timestamp!
  transactionHash: Bytes!
}

type DailyProjectStats
  @aggregation(intervals: ["day"], source: "ProjectProposed") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "count")
}

type DailyProofStats @aggregation(intervals: ["day"], source: "ProofAudited") {
  id: Int8!
  timestamp: Timestamp!

  approvals: BigInt!
    @aggregate(fn: "count", arg: "case when action = 0 then 1 else null end")

  rejections: BigInt!
    @aggregate(fn: "count", arg: "case when action = 2 then 1 else null end")
}

type DailyReviewStats
  @aggregation(intervals: ["day"], source: "ProposalReviewed") {
  id: Int8!
  timestamp: Timestamp!
  count: BigInt! @aggregate(fn: "count")
  approvals: BigInt!
    @aggregate(fn: "count", arg: "case when action = 0 then 1 else null end")

  rejections: BigInt!
    @aggregate(fn: "count", arg: "case when action = 2 then 1 else null end")
}

type DailyCreditStats
  @aggregation(intervals: ["day"], source: "CreditsIssued") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "sum", arg: "amount")
}

type DailyTransactionStats
  @aggregation(intervals: ["day"], source: "Transaction") {
  id: Int8!
  timestamp: Timestamp!
  total: BigInt! @aggregate(fn: "sum", arg: "value")
  count: BigInt! @aggregate(fn: "count")
}

# type ProofSubmitted @entity(immutable: true) {
#   id: Bytes!
#   internal_id: BigInt! # uint256
#   developer: Bytes! # address
#   proofCID: String! # string
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type ProposalReviewed @entity(immutable: true) {
#   id: Bytes!
#   internal_id: BigInt! # uint256
#   auditor: Bytes! # address
#   action: Int! # uint8
#   commentCID: String! # string
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }
